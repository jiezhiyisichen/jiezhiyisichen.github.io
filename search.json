[{"title":"欢迎来到我的网站","url":"/2025/05/08/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99/","content":"献出我的c++笔记：格式化输入输出printf()scanf()格式化输入输出%d :int%c :char\n%f :float\nprintf()            原宽大比2大，则原数据原样输出  \n设置输出内容宽度——|  \n             |\t\t\t\t原宽大比2小，则填充0输出  \n\n修饰符:%02d              |       设置填充字符\n换行符：\\n\nprintf()和scanf()包含在cstdio文件中，所以必须在程序中先包含该文件\nscanf() —— 按规定格式输入内容 —— scanf(“格式字符串”，数据1，数据2)printf() —— 按规定格式输出内容\nsetw()函数setw(n) —-&gt;设置输出内容所占的总宽度nsetfill(c) –&gt;设置填充字符c\ncout&lt;&lt;setw(5)&lt;&lt;18&lt;&lt;endl;\n\n 18 |     1  8| 输出内容宽度大于（设置的宽度）时，则原样输出\ncout&lt;&lt;setw(5)&lt;&lt;18&lt;&lt;endl;只对紧跟其后的内容\n输出时间#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main() &#123;\tint h,m,s,s1;\tcin&gt;&gt;s1;\th=s1/3600;\ts1-=h*3600;\tm=s1/60;\ts1-=m*60;\ts=s1;\tcout&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;s;\treturn 0;&#125;\n\n#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main() &#123;\tint t;\tcin&gt;&gt;t;\tint h=t/60/60;\tint m=t/60%60;    int s=t%60;\tcout&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;h&lt;&lt;&quot;:&quot;;    cont&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;m&lt;&lt;&quot;:&quot;;    cout&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;s;\treturn 0;&#125;\n\n简化形式条件？条件成立执行语句1:条件不成立执行语句2\t\ncout格式化输出float格式#include &lt;iomanip&gt;\n\n\n\n\n控制符\n作用\n\n\n\nfixed\n保留小数点后n位数\n\n\nsetprecision(n)\n保留小数点后n位数\n\n\nfix—&gt;安装、固定\nprecision—&gt;精确度\nfloat a=31.21;cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;a&lt;&lt;endl;//两个控制符必须同时出现，前后顺序无所谓\n\nsetprecision设置原则：四舍五入\nscanf、printf输出floatfloat占位符\n\n\n占位符\n说明\n\n\n\n%d\nint\n\n\n%c\nchar\n\n\n%f\nfloat\n\n\n%g\n去除浮点数float小数尾0\n\n\n%lf\n双精度float\n\n\n%lg\n去除双精度float double小数尾0\n\n\n\n%f占位符默认输出6位小数，不够6位，则在小数后面补0\n\nprintf()实现float格式化输出printf(&quot;%.1f&quot;,b);\n\n\n%.nf 保留小数点后n位\n\n双精度浮点型有效数字和精度有效数字：从一个数的左边第一个非0数字起，到末位数字止，所有的数字都是这个数的有效数字。\n精度就是指有效数字的个数\nfloat的精度float类型的精度是7位有效数字\ndouble数据类型float 单精度浮点型（16位有效数字，精度高）\n%lf 双精度占位符\n字面常量（字面值）将程序中的数字、字符、文本称为字面常量，也称为字面值。\n例如：0,1,18,3.14,4,8，’a’,”hello”等\ndouble类型的3.14 转换成为float类型：3.14f\n整数进行运算的结果还是整数\n自动数据类型转换规则转换规则：低精度-&gt;高精度\n\n\n\n类型\n\n\n\nchar\n\n\nint\n\n\nfloat\n\n\ndouble\n\n\n数据储存到与其数据类型不一致的变量中，也会发生自动数据类型转换\n总结规律strcmp(s1,s1)\n作用：对字符串s1,字符串s2的内容进行比较\n结果&gt;0|1,s1&gt;s2\n&lt;0|-1,s1&lt;s2\n&#x3D;&#x3D;0,s1&#x3D;&#x3D;s2\nstring字符串string是一种数据类型：字符串\nstring类型的变量可以储存字符串\n空格输入string变量输入带空格的字符串\n语法格式：getline(cin,s)\nlength函数string s&#x3D;”1”\n作用：用于计算字符串s的长度\n语法格式：s.length()\n函数定义函数的语法格式数据类型 函数名()\n&#123;    函数体&#125;\n\nvoid 数据类型\n常用四个系统函数\n\n\n函数\n说明\n\n\n\nmax(x,y)\n找出两个最大值\n\n\nmin(x,y)\n找出两个最小值\n\n\nswap(x,y)\n交换\n\n\nsort()\n排序\n\n\n结构体定义结构体的语法格式struct 结构体名\n{\n数据类型1 变量名1；\n}\n#include &lt;bits/stdc++.h&gt;using namespace std;struct stu&#123;    int id;    string name;    double sc;&#125;;int main()&#123;    stu a=&#123;1,&quot;yaya&quot;,98&#125;;    cout&lt;&lt;a.id&lt;&lt;endl&lt;&lt;a.name&lt;&lt;endl&lt;&lt;a.sc;\treturn 0;&#125;\n\n#include &lt;bits/stdc++.h&gt;using namespace std;struct stu&#123;    int id;    string name;    double sc;&#125;;int main()&#123;    stu a[4];    for(int i=1;i&lt;=3;i++)    &#123;        cin&gt;&gt;a[i].id&gt;&gt;a[i].name&gt;&gt;a[i].sc;    &#125;    for(int i=1;i&lt;=3;i++)    &#123;        cout&lt;&lt;a[i].id&lt;&lt;endl&lt;&lt;a[i].name&lt;&lt;endl&lt;&lt;a[i].sc&lt;&lt;endl;    &#125;    \treturn 0;&#125;\n\n数组进阶列对称垂直对称的两个元素，**列下标相加的结果等于n-1。a[i][j]与a[i][n-1-j]**垂直对称。\n行对称水平对称的两个元素，**行下标相加的结果等于n-1。a[i][j]与a[n-1-i][j]**水平对称\n主对角线主对角线上的元素下标：**i&#x3D;&#x3D;j**\n**a[i][j]和a[j][i]**关于主对角线对称。\n副对角线副对角线上的元素下标：**i+j&#x3D;&#x3D;n-1**\n**a[i][j]和a[n-1-j][n-1-i]**关于副对角线对称。\n递推算法\n从已知的**初始条件出发，依据递推关系，推出所求的结果，这种方法称为递推算法**\n\n难题解决#include &lt;bits/stdc++.h&gt;using namespace std;int a[51]=&#123;&#125;,b[51];int main()&#123;\tint x,y,z;    //x+1------z+1 虫=上月虫的数量+前两个月卵的数量    //\t\t\t   卵=x个月虫的数量*y    //x月之前只有一对虫 0对卵\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\tfor(int i=1;i&lt;=x;i++)\t&#123;\t\ta[i]=1;\t&#125;\tfor(int i=x+1;i&lt;=z+1;i++)\t&#123;\t\ta[i]=a[i-1]+b[i-2];\t\tb[i]=a[i-x]*y;\t&#125;\tprintf(&quot;%d&quot;,a[z+1]);\treturn 0;&#125;\n\n前缀和\n前n项的和叫做前缀和\n\n求前缀和数组s[1]&#x3D;a[1] (i&#x3D;1)\ns[i]&#x3D;s[i-1]+a[i]\n前缀和计算区间和计算区间和L~R：s[R]-s[L-1]\n差分3 5 9 19 20 23 30\n差分：**每一项与前一项的差**。\n第一项差分：3-0&#x3D;**3 **\n\n第1个数字的前1项默认为0\n\n性质：对**差分数组求前缀和，得到原数组**。\n栈\n在计算机中有一种容器：\n\n\n\n容器只有一个口进行数据的存取。\n\n\n\n** 2.先存入的数据后取，后存入的数据先取。**\n\n\n叫做：栈\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int a[6]=&#123;&#125;,top;//进栈void push(int x)&#123;\tif(top&lt;5)\t&#123;\t\ta[++top]=x;\t&#125;&#125;//出栈void pop()&#123;if(top&gt;0) a[top--]=0;return;&#125;//获取栈顶int getTop()&#123;return a[top];&#125;//清空栈void clear()&#123;top=0;return;&#125;int main()&#123;\t\t\treturn 0;&#125;\n\n\n\n指针指针结构体struct stu&#123;    int id;    string name;    double score;&#125;;stu a=&#123;1,&quot;yaya&quot;,98.5&#125;;//取结构体变量地址与普通变量相同指针访问数据方式： 指针名-&gt;成员名cout&lt;&lt;p-&gt;id&lt;&lt;endl      =     cout&lt;&lt;a.id&lt;&lt;endl;\n\n指针实行变量交换#include &lt;bits/stdc++.h&gt;using namespace std;void fun(int *a,int *b)&#123;    int x=0;    x=*a;*a=*b,*b=x;&#125;int main()&#123;\tint a=5,b=6;    int *pa=&amp;a,*pb=&amp;b;    //变量a、b的交换    fun(pa,pb);    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;\treturn 0;&#125;\n\n搜索深度优先搜索这种**能深则深，不能深则退的方法，称之为深度优先搜索**\n广度优先搜索node a=&#123;1,1&#125;;q.push(a);vis[1][1]=1;while(q.empty()!=1)&#123;    node f=q.front();    if(mp[f.x][f.y]==2)    &#123;        cout&lt;&lt;&quot;yes&quot;;    &#125;    for(int i=0;i&lt;4;i++)    &#123;        int nx=f.x+dx[i];        int ny=f.y+dy[i];        if(nx&gt;=1 &amp;&amp; nx&lt;=4 &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=4 &amp;&amp; mp[nx][ny]!=1 &amp;&amp; vis[nx][ny]==0)        &#123;            vis[nx][ny]=1;            node r=&#123;nx,ny&#125;;            q.push(r);        &#125;    &#125;    q.pop();&#125;\n\n"}]