[{"title":"Minecraft网易创造小镇计划","url":"/2025/05/27/Minecraft%E7%BD%91%E6%98%93%E5%88%9B%E9%80%A0%E5%B0%8F%E9%95%87%E8%AE%A1%E5%88%92/","content":"可以干什么\n建筑、红石、指令以及15个付费模组，有家具、电梯各种模组随意，有比特萝卜跨存档建筑转移\n\n数据\n更新时间：2025.6.22\n\n房间被熊次数：4次（每次都活了下来）\n备份：true\n防熊：非常完善\n房间来过人数：257人\n房间实体数（卡顿原因之一）：621（实在太多了，做得不好的，有实体存在的作品将删除实体）\n房间状态：关闭\n公告\n1、招聘指令师20名\n2、禁止熊孩子\n3、加入请在网易我的世界搜索好友：jie_zhi火\n\n**最近一次被熊：  **\n\n\n实体数量7560，全是末影龙\n\n优秀作品：\n\n\n\n"},{"title":"Minecraft网易创造小镇计划2","url":"/2025/08/08/Minecraft%E7%BD%91%E6%98%93%E5%88%9B%E9%80%A0%E5%B0%8F%E9%95%87%E8%AE%A1%E5%88%922/","content":"可以干什么建筑、红石、指令以及12个付费模组32个mod，有家具、电梯各种模组随意，有比特萝卜跨存档建筑转移数据房间被熊次数：0次\n备份：true\n防熊：完善\n房间来过人数：386人\n房间状态：未开启\n公告\n1、招聘指令师4名\n2、禁止熊孩子\n3、加入请在网易我的世界搜索好友：jie_zhi火\n4、新增dm维度（第二维度）为玩法建造区\n5、新增雪球菜单8选项，可查看当前状态\n6、新增地皮区（建筑二去）\n7、本房间使用电脑，可容纳更多实体\n\n\n视频****\n"},{"title":"jiezhi的共享文件：123网盘","url":"/2025/08/08/jiezhi%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%9A123%E7%BD%91%E7%9B%98/","content":"对于jiezhi整理的文件和教程，可访问123网盘找到对应的文件下载\n注：123网盘本身不收钱，您需要登录后才能免费下载\n\n网站123：[https://www.123684.com/s/9O42jv-OzCL3](https://www.123684.com/s/9O42jv-OzCL3)\n123备用链接：[https://www.123912.com/s/9O42jv-OzCL3](https://www.123912.com/s/9O42jv-OzCL3)\n无提取码\n二维码：\n\n"},{"title":"jiezhi（易）的c++知识库","url":"/2025/08/12/jiezhi%EF%BC%88%E6%98%93%EF%BC%89%E7%9A%84c++-%E7%9F%A5%E8%AF%86%E5%BA%93/","content":"格式化输入输出printf()scanf()格式化输入输出%d :int%c :char\n%f :float\nprintf()            原宽大比2大，则原数据原样输出  \n设置输出内容宽度——|  \n             |\t\t\t\t原宽大比2小，则填充0输出  \n\n修饰符:%02d              |       设置填充字符\n换行符：\\n\nprintf()和scanf()包含在cstdio文件中，所以必须在程序中先包含该文件\nscanf() —— 按规定格式输入内容 —— scanf(“格式字符串”，数据1，数据2)printf() —— 按规定格式输出内容\nsetw()函数setw(n) —-&gt;设置输出内容所占的总宽度nsetfill(c) –&gt;设置填充字符c\ncout&lt;&lt;setw(5)&lt;&lt;18&lt;&lt;endl;\n\n 18 |     1  8| 输出内容宽度大于（设置的宽度）时，则原样输出\ncout&lt;&lt;setw(5)&lt;&lt;18&lt;&lt;endl;只对紧跟其后的内容\n输出时间#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main() &#123;\tint h,m,s,s1;\tcin&gt;&gt;s1;\th=s1/3600;\ts1-=h*3600;\tm=s1/60;\ts1-=m*60;\ts=s1;\tcout&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;h&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;s;\treturn 0;&#125;\n\n#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main() &#123;\tint t;\tcin&gt;&gt;t;\tint h=t/60/60;\tint m=t/60%60;    int s=t%60;\tcout&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;h&lt;&lt;&quot;:&quot;;    cont&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;m&lt;&lt;&quot;:&quot;;    cout&lt;&lt;setw(2)&lt;&lt;setfill(&#x27;0&#x27;)&lt;&lt;s;\treturn 0;&#125;\n\n简化形式条件？条件成立执行语句1:条件不成立执行语句2\t\ncout格式化输出float格式#include &lt;iomanip&gt;\n\n\n\n\n控制符\n作用\n\n\n\nfixed\n保留小数点后n位数\n\n\nsetprecision(n)\n保留小数点后n位数\n\n\nfix—&gt;安装、固定\nprecision—&gt;精确度\nfloat a=31.21;cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;a&lt;&lt;endl;//两个控制符必须同时出现，前后顺序无所谓\n\nsetprecision设置原则：四舍五入\nscanf、printf输出floatfloat占位符\n\n\n占位符\n说明\n\n\n\n%d\nint\n\n\n%c\nchar\n\n\n%f\nfloat\n\n\n%g\n去除浮点数float小数尾0\n\n\n%lf\n双精度float\n\n\n%lg\n去除双精度float double小数尾0\n\n\n\n%f占位符默认输出6位小数，不够6位，则在小数后面补0\n\nprintf()实现float格式化输出printf(&quot;%.1f&quot;,b);\n\n\n%.nf 保留小数点后n位\n\n双精度浮点型有效数字和精度有效数字：从一个数的左边第一个非0数字起，到末位数字止，所有的数字都是这个数的有效数字。\n精度就是指有效数字的个数\nfloat的精度float类型的精度是7位有效数字\ndouble数据类型float 单精度浮点型（16位有效数字，精度高）\n%lf 双精度占位符\n字面常量（字面值）将程序中的数字、字符、文本称为字面常量，也称为字面值。\n例如：0,1,18,3.14,4,8，’a’,”hello”等\ndouble类型的3.14 转换成为float类型：3.14f\n整数进行运算的结果还是整数\n自动数据类型转换规则转换规则：低精度-&gt;高精度\n\n\n\n类型\n\n\n\nchar\n\n\nint\n\n\nfloat\n\n\ndouble\n\n\n数据储存到与其数据类型不一致的变量中，也会发生自动数据类型转换\n总结规律strcmp(s1,s1)\n作用：对字符串s1,字符串s2的内容进行比较\n结果&gt;0|1,s1&gt;s2\n&lt;0|-1,s1&lt;s2\n&#x3D;&#x3D;0,s1&#x3D;&#x3D;s2\nstring字符串string是一种数据类型：字符串\nstring类型的变量可以储存字符串\n空格输入string变量输入带空格的字符串\n语法格式：getline(cin,s)\nlength函数string s&#x3D;”1”\n作用：用于计算字符串s的长度\n语法格式：s.length()\n函数定义函数的语法格式数据类型 函数名()\n&#123;    函数体&#125;\n\nvoid 数据类型\n常用四个系统函数\n\n\n函数\n说明\n\n\n\nmax(x,y)\n找出两个最大值\n\n\nmin(x,y)\n找出两个最小值\n\n\nswap(x,y)\n交换\n\n\nsort()\n排序\n\n\n结构体定义结构体的语法格式struct 结构体名\n{\n数据类型1 变量名1；\n}\n#include &lt;bits/stdc++.h&gt;using namespace std;struct stu&#123;    int id;    string name;    double sc;&#125;;int main()&#123;    stu a=&#123;1,&quot;yaya&quot;,98&#125;;    cout&lt;&lt;a.id&lt;&lt;endl&lt;&lt;a.name&lt;&lt;endl&lt;&lt;a.sc;\treturn 0;&#125;\n\n#include &lt;bits/stdc++.h&gt;using namespace std;struct stu&#123;    int id;    string name;    double sc;&#125;;int main()&#123;    stu a[4];    for(int i=1;i&lt;=3;i++)    &#123;        cin&gt;&gt;a[i].id&gt;&gt;a[i].name&gt;&gt;a[i].sc;    &#125;    for(int i=1;i&lt;=3;i++)    &#123;        cout&lt;&lt;a[i].id&lt;&lt;endl&lt;&lt;a[i].name&lt;&lt;endl&lt;&lt;a[i].sc&lt;&lt;endl;    &#125;    \treturn 0;&#125;\n\n数组进阶列对称垂直对称的两个元素，**列下标相加的结果等于n-1。a[i][j]与a[i][n-1-j]**垂直对称。\n行对称水平对称的两个元素，**行下标相加的结果等于n-1。a[i][j]与a[n-1-i][j]**水平对称\n主对角线主对角线上的元素下标：**i&#x3D;&#x3D;j**\n**a[i][j]和a[j][i]**关于主对角线对称。\n副对角线副对角线上的元素下标：**i+j&#x3D;&#x3D;n-1**\n**a[i][j]和a[n-1-j][n-1-i]**关于副对角线对称。\n递推算法\n从已知的**初始条件出发，依据递推关系，推出所求的结果，这种方法称为递推算法**\n\n难题解决#include &lt;bits/stdc++.h&gt;using namespace std;int a[51]=&#123;&#125;,b[51];int main()&#123;\tint x,y,z;    //x+1------z+1 虫=上月虫的数量+前两个月卵的数量    //\t\t\t   卵=x个月虫的数量*y    //x月之前只有一对虫 0对卵\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\tfor(int i=1;i&lt;=x;i++)\t&#123;\t\ta[i]=1;\t&#125;\tfor(int i=x+1;i&lt;=z+1;i++)\t&#123;\t\ta[i]=a[i-1]+b[i-2];\t\tb[i]=a[i-x]*y;\t&#125;\tprintf(&quot;%d&quot;,a[z+1]);\treturn 0;&#125;\n\n前缀和\n前n项的和叫做前缀和\n\n求前缀和数组s[1]&#x3D;a[1] (i&#x3D;1)\ns[i]&#x3D;s[i-1]+a[i]\n前缀和计算区间和计算区间和L~R：s[R]-s[L-1]\n差分3 5 9 19 20 23 30\n差分：**每一项与前一项的差**。\n第一项差分：3-0&#x3D;**3 **\n\n第1个数字的前1项默认为0\n\n性质：对**差分数组求前缀和，得到原数组**。\n栈\n在计算机中有一种容器：\n\n\n\n容器只有一个口进行数据的存取。\n\n\n\n** 2.先存入的数据后取，后存入的数据先取。**\n\n\n叫做：栈\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int a[6]=&#123;&#125;,top;//进栈void push(int x)&#123;\tif(top&lt;5)\t&#123;\t\ta[++top]=x;\t&#125;&#125;//出栈void pop()&#123;if(top&gt;0) a[top--]=0;return;&#125;//获取栈顶int getTop()&#123;return a[top];&#125;//清空栈void clear()&#123;top=0;return;&#125;int main()&#123;\t\t\treturn 0;&#125;\n\n\n\n指针指针结构体struct stu&#123;    int id;    string name;    double score;&#125;;stu a=&#123;1,&quot;yaya&quot;,98.5&#125;;//取结构体变量地址与普通变量相同指针访问数据方式： 指针名-&gt;成员名cout&lt;&lt;p-&gt;id&lt;&lt;endl      =     cout&lt;&lt;a.id&lt;&lt;endl;\n\n指针实行变量交换#include &lt;bits/stdc++.h&gt;using namespace std;void fun(int *a,int *b)&#123;    int x=0;    x=*a;*a=*b,*b=x;&#125;int main()&#123;\tint a=5,b=6;    int *pa=&amp;a,*pb=&amp;b;    //变量a、b的交换    fun(pa,pb);    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;\treturn 0;&#125;\n\n搜索深度优先搜索这种**能深则深，不能深则退的方法，称之为深度优先搜索**\n#include &lt;iostream&gt;using namespace std;char mp[25][25];int vis[25][25],n,m,ans=0;int dx[4]=&#123;1,0,-1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;void dfs(int x,int y)&#123;\tfor(int i=0;i&lt;4;i++)\t&#123;\t\tint fx=x+dx[i];\t\tint fy=y+dy[i];\t\tif(fx&gt;=0&amp;&amp;fx&lt;n&amp;&amp;fy&gt;=0&amp;&amp;fy&lt;m&amp;&amp;vis[fx][fy]==0&amp;&amp;mp[fx][fy]==&#x27;#&#x27;)\t\t&#123;\t\t\tvis[fx][fy]=1;\t\t\tdfs(fx,fy);\t\t&#125;\t&#125;&#125;int main()&#123;\tcin&gt;&gt;n&gt;&gt;m;\tfor(int i=0;i&lt;n;i++)\t&#123;\t\tfor(int j=0;j&lt;m;j++)\t\t&#123;\t\t\tcin&gt;&gt;mp[i][j];\t\t&#125;\t&#125;\tfor(int i=0;i&lt;n;i++)\t&#123;\t\tfor(int j=0;j&lt;m;j++)\t\t&#123;\t\t\tif(mp[i][j]==&#x27;w&#x27;&amp;&amp;vis[i][j]==0)\t\t\t&#123;\t\t\t\tans++;\t\t\t\tvis[i][j]=1;\t\t\t\tdfs(i,j);\t\t\t&#125;\t\t\t\t\t&#125;\t&#125;\tcout&lt;&lt;ans;&#125;\n\n#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;void dfs(int node, const vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited) &#123;    visited[node] = true;    cout &lt;&lt; node &lt;&lt; &quot; &quot;;        for (int neighbor : adj[node]) &#123;        if (!visited[neighbor]) &#123;            dfs(neighbor, adj, visited);        &#125;    &#125;&#125;void startDFS(int startNode, const vector&lt;vector&lt;int&gt;&gt;&amp; adj) &#123;    int numNodes = adj.size();    vector&lt;bool&gt; visited(numNodes, false);        dfs(startNode, adj, visited);&#125;int main() &#123;    // 示例图的邻接表表示    vector&lt;vector&lt;int&gt;&gt; adj = &#123;        &#123;1&#125;,        &#123;0, 2, 3&#125;,        &#123;1, 4&#125;,        &#123;1, 4&#125;,        &#123;2, 3&#125;    &#125;;        int startNode = 0;    cout &lt;&lt; &quot;DFS遍历顺序: &quot;;    startDFS(startNode, adj);    cout &lt;&lt; endl;        return 0;&#125;\n\n广度优先搜索node a=&#123;1,1&#125;;q.push(a);vis[1][1]=1;while(q.empty()!=1)&#123;    node f=q.front();    if(mp[f.x][f.y]==2)    &#123;        cout&lt;&lt;&quot;yes&quot;;    &#125;    for(int i=0;i&lt;4;i++)    &#123;        int nx=f.x+dx[i];        int ny=f.y+dy[i];        if(nx&gt;=1 &amp;&amp; nx&lt;=4 &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=4 &amp;&amp; mp[nx][ny]!=1 &amp;&amp; vis[nx][ny]==0)        &#123;            vis[nx][ny]=1;            node r=&#123;nx,ny&#125;;            q.push(r);        &#125;    &#125;    q.pop();&#125;\n\n例题：\n#include &lt;bits/stdc++.h&gt;const int Z=200;using namespace std;struct X&#123;\tint a,b,c;&#125;;int n,m,u,v,w,x,d[4][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;char g[Z][Z];bool vis[Z][Z];queue&lt;X&gt; q;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)\t&#123;\t\tfor(int j=1;j&lt;=m;j++)\t\t&#123;        cin&gt;&gt;g[i][j];        if(g[i][j]==&#x27;S&#x27;)\t\t&#123;\t\t\tu=i;v=j;\t\t&#125;        if(g[i][j]==&#x27;T&#x27;)\t\t&#123;\t\t\tw=i;\t\t\tx=j;\t\t&#125;\t\t&#125;    &#125;    q.push(&#123;u,v,0&#125;);\tvis[u][v]=1;    while(!q.empty())\t&#123;        X y=q.front();q.pop();        if(y.a==w&amp;&amp;y.b==x)\t\t&#123;\t\t\tcout&lt;&lt;y.c;\t\t\treturn 0;\t\t&#125;        for(int i=0;i&lt;4;i++)\t\t&#123;            int p=y.a+d[i][0],r=y.b+d[i][1];            if(p&gt;0&amp;&amp;p&lt;=n&amp;&amp;r&gt;0&amp;&amp;r&lt;=m&amp;&amp;g[p][r]!=&#x27;#&#x27;&amp;&amp;!vis[p][r])\t\t\t&#123;                vis[p][r]=1;\t\t\t\tq.push(&#123;p,r,y.c+1&#125;);            &#125;        &#125;    &#125;    return 0;&#125;\n\n排序冒泡排序冒泡排序原理冒泡排序是一种简单的排序算法，通过重复遍历数组，比较相邻元素并交换顺序不对的元素，将较大的元素逐渐“浮”到数组末尾。具体步骤如下：1遍历数组，比较每一对相邻元素，交换顺序不对的元素。2每次遍历将最大的未排序元素移动到正确的位置。3重复上述过程，直到整个数组有序。时间复杂度●最好情况：O(n)（数组已有序）●最坏情况：O(n²)（数组逆序）C++实现代码****代码解释1bubbleSort函数实现冒泡排序：○使用双重循环，外层控制遍历次数，内层进行元素比较和交换。○swapped标志检测是否发生交换，若未交换则提前退出。2main函数测试排序效果：○初始化数组，调用排序函数。○输出排序前后的数组，验证结果。优化●添加swapped标志以提前退出，减少不必要的遍历，提升效率。输出示例\n1\n2\n排序前数组：64 34 25 12 22 11 90 \n排序后数组：11 12 22 25 34 64 90 \n数位while循环剥离方法1#include &lt;iostream&gt; int main() &#123;    int num = 12345;    while (num &gt; 0) &#123;        int lastDigit = num % 10; // 获取个位数        std::cout &lt;&lt; &quot;剥离的个位数是: &quot; &lt;&lt; lastDigit &lt;&lt; std::endl;        num /= 10; // 去掉个位数    &#125;    return 0;&#125;\n\n从低位向高位剥离#include &lt;iostream&gt; int main() &#123;    int num = 12345;    while (num &gt; 0) &#123;        int lastDigit = num % 10; // 获取个位数        std::cout &lt;&lt; &quot;剥离的数位是: &quot; &lt;&lt; lastDigit &lt;&lt; std::endl;        num /= 10; // 去掉个位数    &#125;    return 0;&#125;\n\n从高位向低位剥离#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;cmath&gt; int reverseNumber(int num) &#123;    int reversedNum = 0;    while (num &gt; 0) &#123;        reversedNum = reversedNum * 10 + (num % 10);        num /= 10;    &#125;    return reversedNum;&#125; int main() &#123;    int num = 12345;    num = reverseNumber(num);    while (num &gt; 0) &#123;        int lastDigit = num % 10;         std::cout &lt;&lt; &quot;剥离的数位是: &quot; &lt;&lt; lastDigit &lt;&lt; std::endl;        num /= 10;     return 0;&#125;\n\n夏令营c++笔记截取字符串字符串名.substr(1,2)//截取范围，下标从0开始\n#include &lt;bits/stdc++.h&gt;using namespace std;string s;int main()&#123;\tcin&gt;&gt;s;    int a,b;    cin&gt;&gt;a&gt;&gt;b;    cout&lt;&lt;s.substr(a,b);\treturn 0;&#125;\n\n消除字符串字符串名.erase(0,1)\n判断质数要判断一个数是否为质数，我们可以使用优化的试除法。质数只能被1和它本身整除。以下是判断质数的C++代码及原理说明：\n#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(int n)&#123;\tif(n&lt;=1)    &#123;\t\treturn false;\t&#125;\tif(n&lt;=3)    &#123;\t\treturn true;\t&#125;\tif(n%2==0 || n%3==0)    &#123;\t\treturn false;\t&#125;\tfor(int i=5;i*i&lt;=n;i+=6)    &#123;\t\tif(n%i==0 || n%(i+2)==0)        &#123;\t\t\treturn false;\t\t&#125;\t&#125;\treturn true;&#125;int main()&#123;\tint n;\tcout&lt;&lt;&quot;输入一个整数：&quot;;\tcin&gt;&gt;n;\tif(isPrime(n))    &#123;\t\tcout&lt;&lt;n&lt;&lt;&quot; 是质数。&quot;&lt;&lt;endl;\t&#125;    else    &#123;\t\tcout&lt;&lt;n&lt;&lt;&quot; 不是质数。&quot;&lt;&lt;endl;\t&#125;\treturn 0;&#125;\n\n原理说明\n\n处理特殊情况：○ 如果n小于等于1，直接返回false，因为质数必须大于1。○ 如果n是2或3，直接返回true，因为它们是质数。○ 如果n能被2或3整除，返回false，因为它们不是质数（除了2和3本身）。\n优化的试除法：○ 从5开始，检查到√n为止。○ 由于所有质数大于3都可以表示为6k ± 1，所以每次增加6，并检查i和i+2是否能整除n。○ 如果在循环中找到任何能整除n的数，返回false。\n主函数：○ 读取输入的整数n。○ 调用isPrime函数判断n是否为质数，并输出结果。这个方法通过减少不必要的检查，提高了判断质数的效率。\n\n最大公约数的函数__gcd(1,2)\n队列队列定义queue&lt;int&gt; 名\n函数queue&lt;int&gt; l;l.push(1);//放入l.front();//获取队首l.pop();//出队l.empty();//有数据T，无Fl.size();//返回长度\n\n栈定义stack&lt;int&gt;\n函数(constructor).empty().push().top().empty().size()\n二分模版代码#include &lt;bits/stdc++.h&gt;using namespace std;#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int main()&#123;    int n,f=0;    cin&gt;&gt;n;    int a[900000]=&#123;&#125;;    for(int i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;a[i];    &#125;    sort(a,a+n);    int x;    cin&gt;&gt;x;    int l=0,r=n-1,res=-1;    while(l&lt;=r)    &#123;        int mid=l+(r-l)/2;        if(a[mid]&gt;=x)        &#123;            r=mid-1;            if(a[mid]==x)            &#123;                f=1;                res=mid+1;            &#125;        &#125;        else        &#123;            l=mid+1;        &#125;    &#125;    cout&lt;&lt;res;    return 0;&#125;\n向左找while(l&lt;r)&#123;    int mid=l+(r-l)/2;    if(a[mid]&gt;m)    &#123;        r=mid;    &#125;    else    &#123;        l=mid+1;    &#125;"},{"title":"实时分享","url":"/2025/08/12/%E5%AE%9E%E6%97%B6%E5%88%86%E4%BA%AB/","content":"#include &lt;bits/stdc++.h&gt;using namespace std;int b(int n,int a,int target,int k\\[])&#123;    bool v\\[n+1]=&#123;false&#125;;    queue&lt;int&gt;q;    q.push(a);    int steps\\[n+1]=&#123;0&#125;;    v\\[a]=true;    while(!q.empty())    &#123;        int c=q.front();        q.pop();        if (c==target)        &#123;            return steps\\[c];        &#125;        if(c+k\\[c-1]&lt;=n \\&amp;\\&amp; !v\\[c+k\\[c-1]])        &#123;            v\\[c+k\\[c-1]]=true;            steps\\[c+k\\[c-1]]=steps\\[c]+1;            q.push(c+k\\[c-1]);        &#125;        if(c-k\\[c-1]&gt;=1 \\&amp;\\&amp; !v\\[c-k\\[c-1]])        &#123;            v\\[c-k\\[c-1]]=true;            steps\\[c-k\\[c-1]]=steps\\[c]+1;            q.push(c-k\\[c-1]);        &#125;    &#125;    return -1;&#125;int main()&#123;    int n,a,tctm;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;tctm;    int k\\[n];    for(int i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;k\\[i];    &#125;    int r=b(n,a,tctm,k);    cout&lt;&lt;r;    return 0;&#125;\n\n"},{"title":"jiezhi(易)的python知识库","url":"/2025/08/12/jiezhi-%E6%98%93-%E7%9A%84python%E7%9F%A5%E8%AF%86%E5%BA%93/","content":"鼠标按下事件pygame获取所有事件列表\npygame.event.get()\n\n获取事件类型\nevent.type\n\n退出事件\nevent.tupe==QUIT\n\n鼠标按下事件\nevent.type==MOUSEBUTTONDOWN\n\n获取鼠标按键的键值\nevent.button\n\n鼠标按键的键值为1表示鼠标左键按下\nevent.button==1\n\n鼠标移动事件event.type==MOUSEMOTION\n\nevent.pos[0]\n\nevent.pos[1]\n\n键盘按下事件event.type==KEYDOWN\n\nevent.type==KEYUP\n\nevent.key\n\nevent.key==K_SPACE\n\nevent==K_UP\n\nevent.key==K_DOWN\n\nenvent.key==K_LEFT\n\nevent.key==K_RIGHT\n\n####\t\t\t\t\t设置发送两个事件的间隔#\t\t\t\t\t\t\t   |#单位毫秒                       |pygame.key.set_repeat(delay,interval)#                       |#\t\t\t\t\t\t|#            设置多久后发送第一个KEYDOWN事件\n\n状态handleEvent()state=&#x27;START&#x27;\n\nconEnter()#产生所有对象comPaint()#绘制所有对象comMove()#让所有对象移动isActionTime()#用于判断是否开始行动checkHit()#用于判断碰撞检测fillText()#书写文字state=&#x27;RUNNING&#x27;\n\nstate=&#x27;WIN&#x27;state=&#x27;LOSE&#x27;\n\n递归函数定义:递归算法通常用自定义函数来实现，这个函数称为递归函数f(n)就是递归函数\n函数基本结构:包括递归出口和递归操作递归出口是指函数在什么情况下停止递归递归操作是指函数在递归过程中需要执行的操作按照先书写递归出口再书写递归操作的顺序编写代码\ni=0def fun():\tglobal i\ti+=1\tif i&lt;5:\t\tprint(f&quot;进入第&#123;i&#125;层&quot;)\t\tfun()\t\ti-=1\t\tprint(f&quot;回归第&#123;i&#125;层&quot;)fun()\n\n设计递归函数的三要素第一要素：明确函数要干什么\n第二要素：寻找递归结束条件\n第三要素：找出函数的等价关系式\n题目描述假设有五位同学，他们的编号分别为1、2、3、4、5。从1号同学开始到5号同学为止，每位同学拥有的金币数比相邻的下一位同学多1枚。已知5号同学有10枚金币，问1号同学有几枚\n金币?\n输入描述无\n输出描述无\n样例输入1无\n样例输出114\n、\n#定义函数def f(n):    #递归出口    if n==5:        return 10    #递归操作    return f(n+1)+1#调用函数print(f(1))\n\n\n\n\ndef f(n):\tif n==1 or n==2:\t\treturn 1\telse:\t\treturn f(n-1)+f(n-2)print(&quot;一年后兔子总对数为:&quot;,f(12))\n\n查找(二分查找、插补查找、分块查找)二分查找:::info中间值：mid&#x3D;(min+max)&#x2F;&#x2F;2\n目标&gt;中间值\nmin&#x3D;mid+1\n目标&gt;中间值\nmax&#x3D;mid-1\n目标&#x3D;中间值\n:::\n#目标数字n=9#最小索引&amp;最大索引min=0max=len(a)-1while min&lt;=max:    #中间索引    mid=(min+max)//2    #目标数字比中间数字大    if n&gt;a[mid]:        #调整最小索引，在中间索引基础上加1        min=mid+1    #目标数字比中间数字小    elif n&lt;a[mid]:        #调整最大索引，在中间索引基础上减1        max=mid-1    else:        #输出索引，跳出循环        print(f&quot;目标元素的索引为&#123;mid&#125;&quot;)        break\n\n插补查找mid&#x3D;left+(target-data[left])&#x2F;&#x2F;(data[right]-data[left])*(right-left)\n▪mid:分界（分区）索引\t\t\t\t\t •target:目标数据\n▪left：最左侧数据的索引\t\t\t\t▪date[left]：最左侧数据值\n▪right：最右侧数据的索引\t\t\t\t▪data[right]:最右侧数据值\ndata=[34,53,57,68,72,81,89,93,99]#目标数据、最左侧数据的索引、最右侧数据的索引target=53left=0right=len(data)-1while left&lt;=right:    #使用公式计算分区索引值    mid=left+(target-data[left])/(data[right]-data[left])*(right-left)    #取整    mid=int(mid)    #目标数据大于分区值    if target &gt; data[mid]:        left=mid+1    #目标数据小于分区值    elif target&lt;data[mid]:        right=mid-1    #目标数据等于分区值（成功查找到目标数据）    else:        #输出当前索引，跳出循环        print(f&quot;数字&#123;target&#125;的索引为&#123;mid&#125;&quot;)        break\n\n分块查找1.分块data=[23,43,56,78,97,100,120,135,147,150,155]#目标数字target=150#每块长度b_length=4#分块数量b_num=len(data)//b_length#总长度除以每块长度存在余数，分块数量应增加一if len(data)%b_length:    b_num+=1print(f&quot;总共可分为&#123;b_num&#125;块&quot;)\n\n2.遍历分好的块#遍历分好的三块for b_i in range(b_num):    #开始索引    start=b_i*b_length    #结束索引    end=(b_i+1)*b_length-1    #末尾块结束索引超出，限制范围    if end&gt;=len(data):        end=len(data)-1\n\n3.查找#目标元素大于每块最大值，跳过本次循环（跳过当前块）if target&gt;data[end]:    continue#目标元素小于等于每块最大值，在当前块查找目标元素（顺序查找）for i in range(start,end+1):    if target==data[i]:        index=i        breakbreakprint(f&quot;数字&#123;target&#125;在列表中的索引为&#123;index&#125;&quot;)\n\n4.完整代码data=[23,43,56,78,97,100,120,135,147,150,155]#目标数字target=150#每块长度b_length=4#分块数量b_num=len(data)//b_length#总长度除以每块长度存在余数，分块数量应增加一if len(data)%b_length:    b_num+=1#遍历分好的三块for b_i in range(b_num):    #开始索引    start=b_i*b_length    #结束索引    end=(b_i+1)*b_length-1    #末尾块结束索引超出，限制范围    if end&gt;=len(data):        end=len(data)-1    #目标元素大于每块最大值，跳过本次循环（跳过当前块）    if target&gt;data[end]:        continue    #目标元素小于等于每块最大值，在当前块查找目标元素（顺序查找）    for i in range(start,end+1):        if target==data[i]:            index=i            break    breakprint(f&quot;数字&#123;targe&#125;在列表中的索引为&#123;index&#125;&quot;)\n\n递归递归函数定义:递归算法通常用自定义函数来实现，这个函数称为递归函数f(n)就是递归函数\n函数基本结构:包括递归出口和递归操作递归出口是指函数在什么情况下停止递归递归操作是指函数在递归过程中需要执行的操作按照先书写递归出口再书写递归操作的顺序编写代码\n切片选取从开始到结束的部分，以步长为间隔选择\n不包含本身\n  |\n列表名[开始:结束:步长]\n   |\n可省略，默认为1\n\nn=eval(input())n_ns=[]for i in range(len(n)):\tfor j in range(i+1,len(n)):\t\tn1=n[i]\t\tn2=n[j]\t\tn_n=n2[0]+n1[1:]+&#x27;-&#x27;+n1[0]+n2[1:]\t\tif n_n not in n_ns and len(n_n)!=11:\t\t\tn_ns.append(n_n)print(f&quot;有效的名字的数量为:&#123;len(n_ns)&#125;&quot;)\n\n\n\n\n\n切片分割年月日‘2025  12  20’\n 0123456789\n年:int(date[:4])–&gt;2025\n月:int(date[5:7])–&gt;12\n日:int(date[7:])–&gt;20\n\nsplit()n = input().split(&#x27; &#x27;)split(‘分割符’)函数  分隔字符串，返回列表date1 = list(map(int,n[0].split(&#x27;-&#x27;)))date2 = list(map(int,n[1].split(&#x27;-&#x27;)))print(date1,date2)\n\nmap()\n"},{"title":"欢迎来到我的网站","url":"/2025/05/25/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99/","content":":::info\n在这里你可以随便逛逛，如果内容较多，可以点击搜索，搜素帖子，现在，让我们一起开始Minecraft游戏吧:::\n点击左下角方块可以播放音乐\n"}]